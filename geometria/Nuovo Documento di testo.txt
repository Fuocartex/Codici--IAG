/* Funzione per calcolare l'inversa di una matrice intera
int** invert_matrix_integer(int** matrix, int size) {
    // Costruzione della matrice estesa [A | I]
	int** augmented = (int**)calloc(size, sizeof(int*));
    int** inverse = (int**)calloc(size, sizeof(int*));
	for (int i = 0; i < size; i++) {
		augmented[i] = (int*)calloc(2 * size, sizeof(int));
		inverse[i] = (int*)calloc(size, sizeof(int));
	}
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            augmented[i][j] = matrix[i][j]; // Parte della matrice originale
            augmented[i][j + size] = (i == j) ? 1 : 0; // Parte della matrice identità
        }
    }

    // Riduzione a scala
    for (int i = 0; i < size; i++) {
        // Trova il pivot non nullo
        if (augmented[i][i] == 0) {
            // Cerca un'altra riga da scambiare
            int swap_row = -1;
            for (int k = i + 1; k < size; k++) {
                if (augmented[k][i] != 0) {
                    swap_row = k;
                    break;
                }
            }
            if (swap_row == -1) {
                printf("Errore: La matrice non è invertibile.\n");
                return 0;
            }
            // Scambia le righe
            for (int j = 0; j < 2 * size; j++) {
                int temp = augmented[i][j];
                augmented[i][j] = augmented[swap_row][j];
                augmented[swap_row][j] = temp;
            }
        }

        // Normalizza la riga corrente usando l'MCD
        for (int k = 0; k < size; k++) {
            if (k != i) {
                int factor = augmented[k][i] / gcd(augmented[i][i], augmented[k][i]);
                for (int j = 0; j < 2 * size; j++) {
                    augmented[k][j] -= factor * augmented[i][j];
                }
            }
        }
    }

    // Controlla se il determinante è ±1
    for (int i = 0; i < size; i++) {
        if (augmented[i][i] != 1 && augmented[i][i] != -1) {
            printf("Errore: La matrice non è unimodulare, quindi non ha un'inversa intera.\n");
            return 0;
        }
    }

    // Estrai la matrice inversa dalla parte destra
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            inverse[i][j] = augmented[i][j + size];
        }
    }

    return inverse; // Successo
}*/